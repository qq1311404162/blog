### 作用域
作用域：一套引擎寻找变量的规则

**词法作用域：寻找变量的规则，在书写代码的时候便已确定，与调用的位置无关**（划重点）

JS 作用域的工作模型就是词法作用域


```
// 这是个最简单的例子
var a = 1;

function testOne(){
    console.log(a);
}

function testTwo(){

    var a = 2;
    testOne();
}
testTwo(); // -> 1
```
    


### JS 作用域
JS 中除了全局作用域之外，只有函数可以创建作用域。其创建的作用域一般称为**函数作用域**

特点
* 作用域嵌套，下级作用域能够访问并使用上级作用域的变量
* 具有相同的执行上下文顺序
* 函数作用域中 var 声明的变量，外部无法访问
* 传统 JS 中没有块级作用域

**特例：JS 中的块级作用域**
1. es6 中let/const 定义的变量/常量属于块级作用域
2. try/catch 中 catch内部为块级作用域，外部无法访问其定义的变量
3. with 语句内的变量，内部非 var 定义的变量，外部无法访问


### JS 执行上下文
**执行上下文其实就是 JS 代码的执行环境。**

执行环境定义了变量和函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有与之对应的**变量对象**，保存着该环境所定义的所有变量和函数。我们无法通过代码来访问该变量对象，但是解析器在处理数据时会在后台用到它。

JS 中的 3 种执行环境
1. 全局执行环境，最外围的一个执行环境。代码载入时，全局环境被创建
2. 函数执行环境，每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就被推入一个栈中，执行完毕后，将其弹出，控制权返回给之前的执行环境。
3. eval 环境，执行 eval 函数时运行的环境


JS 引擎生成执行环境的 2 个阶段
1. 创建阶段，此阶段中 JS 解释器会找出定义的变量和函数，并给他们提前在内存中开辟好空间

    * 建立变量，函数，参数等
        * 函数参数，arguments 赋值
        * 遇到 var 定义的变量，内存中赋值为 undefined，命名冲突则忽略后面的变量
        * 遇到函数声明，将整个函数存入内存中，命名冲突则覆盖前面的变量
    * 建立作用域链，根据词法作用域，创建作用域链
    * this 赋值
2. 执行阶段，变量赋值，函数引用，其他代码

JS 中，每次执行函数都会创建一个新的执行环境
