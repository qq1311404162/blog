## 基础语法
JavaScript 基础语法包括：变量声明，数据类型，函数，控制语句和内置对象
### 变量声明
ES5 中，使用 var 和 function 声明普通变量和函数

ES6 中，新增 let、const、import 和 class，分别用来声明 普通变量、静态变量、模块 和 类
### 数据类型
共 7 中数据类型，分别是 Null、Undefined、Boolean、String、Number、Symbol 和 Object。其中 Object 是引用类型，其他的都是原始类型
##### 原始类型(Primitive Type)
又称为基本类型，因为其占据空间稳定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈(Strck) 中

为了便于操作这类数据，ECMAScript 提供了 3 个基本包装类型：Boolean、String 和 Number。它们是一种特殊的引用类型，**每当读取一个基本类型值的时候，JavaScript 内部会创建一个对应的包装对象，从而可以调用一些方法来操作这些数据**
##### 引用类型
由于其值的大小会变，所以不能放在栈中，否则会**降低变量查询速度**，因此存储在堆(heap) 中，存储在变量处的是一个指针，指向堆中的内存地址。

引用类型可以为其添加、删除和修改属性和方法，但是基本类型不行

**JavaScript 中万物皆对象，但对象也有区别，大致分为普通对象(Object)和函数对象(Function)**

通过 new Function 产生(即函数定义)的对象都是函数对象，其他对象都是普通对象
##### 类型判断
共有 4 中判断类型的方法，分别为 typeof、instanceof、constructor、toString
### 函数
JavaScript 中，函数有 3 种角色，即普通函数、构造函数和对象方法。**同一个函数，调用方式不同，函数的作用不一样**

JS 直接调用就是普通函数；通过 new 创建对象时就是构造函数；通过对象调用时就是对象方法。
### 控制语句
### 内置对象
常用的内置对象有 Date、Array、JSON、RegExp、Boolean、String 和 Number 等等。

JSON 主要用于对象的序列化和反序列化，还有一个作用就是实现对象的深拷贝
RegExp 是正则表达式
## 函数原型链
JavaScript 是一种基于对象的语言，为了具备继承的能力，JavaScript 在函数对象上建立了远行对象 prototype，并以函数对象为主线，从上至下，在 JS 内部构建了一条原型链，将一个个独立的对象联系在一起

简单来说，原型链就是一种**变量查找机制**。当访问一个对象的属性时，先查找对象本身是否存在，如果不存在就去该对象所在的原型链上去查找，知道 Object 对象为止，如果还没有找到则返回 undefined。
## 函数作用域
变量在声明他们的函数体以及这个函数体的嵌套的任意函数体内都是有意义的。即在一个函数里，有些变量可以访问，有些变量不可以访问。那些能访问变量所形成的范围，就是函数的作用域

JavaScript 中没有块级作用域，只有函数作用域
##### 作用域链 和 JS 引擎工作原理
## this 指针
this 指针存在于函数中，用以标识函数运行时所处的上下文。函数类型不同，this 指向规则也不一样
* 对于普通函数，this 始终指向全局对象 window
* 对于构造函数，this 指向新创建的对象
* 对于对象方法，this 指向调用该方法的对象

Function 对象也提供了 call、apply 和 bind 方法来改变函数的 this 指向
## new 操作符
函数的创建方式有 3 中，即显示声明、匿名定义 和 new Function()

当使用 new 来创建对象时，JS 将新对象的原型链指向了构造函数的原型对象，建立一条原型链，通过新对象可以访问到对象原型中的方法和属性
## 闭包
一个有权访问另一个函数作用域的函数
## 单线程与事件循环
JavaScript 是单线程语言。但是浏览器中一些任务是很耗时的，如 Ajax 请求，定时器，事件处理等。为了保证主线程上的任务不被阻塞，JavaScript 内部维护了一个任务队列，当耗时任务结束时，就将对应的回调函数插入队列中进行等待。这些任务的执行时机并不确定，只有当所有同步任务执行完毕后，执行环境栈被清空以后，再从任务队列中依次读取回调函数，并将其压入执行环境栈中，执行完毕后再从栈中弹出，栈被清空

事件循环：主线程从任务队列中读取任务是不断循环的，每当栈被清空后，主线程就会从任务队列中读取新的任务并执行，如果没有新的任务，就会一直等待
## Ajax 和跨域技术
### Ajax
Ajax 是浏览器专门用来和服务器进行交互的异步通讯技术，核心对象是 XMLHTTPRequest，通过该对象可以创建一个 Ajax 请求，当请求发出后，Ajax 提供了两个状态位来描述请求在不同阶段的状态，分别是 readyState 和 status，Ajax 还可以设置一个 timeout 值，代表超时时间(timeout 只会影响 readyState，而不会影响 status，因为超时只会中断数据传输，不会影响服务器的处理结果)

readyState 通过 5 个状态码来描述一个请求的 5 个阶段
* 0 - 初始化阶段，请求未发送
* 1 - 请求发送中，服务器还未收到请求
* 2 - 请求发送成功，服务器已收到请求
* 3 - 服务器处理完成，开始响应请求，传输数据
* 4 - 客户端收到请求，并完成了数据下载，生成了相应对象

status 用于描述服务端对请求处理的情况，比如 200 表示正确响应请求，404 表示找不到服务器资源等等
### 同源策略
为了保证用户信息的安全，浏览器引入了同源策略，Ajax只能请求和当前地址同域(**协议、端口和域名全部相同**)的服务器资源。
### 跨域
###### JSONP
HTML 标签没有同源策略，新增一个 script 标签指向需要访问的地址并提供一个回调函数来接收数据。但是仅用于 GET 请求
###### CORS 跨域资源共享
一个规范，当浏览器发现该请求需要跨域时，会自动在头信息中添加一个 Origin 字段，说明本次请求来自哪个源，服务器根据这个值，决定是否同意这次请求
### Fetch
由于 XMLHTTPRequest 是一个设计粗糙的 API，不符合关注分离的原则，配置和调用方式非常混乱。Fetch 应运而生，是基于 Promise 思想设计的 Ajax 接口 
## 模块化
JavaScript 之前一直没有模块化体系，即无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。ES6 之前，社区制定了一些模块化方案，主要有 CMD 和 AMD，以 commonjs 和 requirejs 为代表。ES6 实现了模块化编程，其设计思想是，尽量静态化，使得编译时就能确定模块的依赖关系
## ES6
比较重大的变化
* 新增 let、const 命令来声明变量，和 var 相比，不存在变量提升问题，出现块级作用域。const 声明的变量不允许在后续逻辑中改变；
* 新增结构赋值，rest 语法，箭头函数等，为了让代码看起来更加简洁
* 新增模块化机制，让前端更方便实现工程化
* 新增类和继承的概念，配合模块化，实现高复用，高扩展的系统架构
* 新增模板字符串，高效简洁
* 新增 Promise 机制，解决异步回调多层嵌套的问题
## Node.js
一个基于 Chrome V8 引擎的 Javascript 运行环境，它的运行不依赖于浏览器作为宿主环境，而是和服务端程序一样可以独立运行。Node.js 的优势在于单线程和异步 I/O 模型，实现了一个高并发、高性能的运行时环境。相比其他传统多线程模型，Node.js 实现简单，并且可以减少资源开销