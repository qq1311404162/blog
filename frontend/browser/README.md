## 事件基础

### 事件机制
事件触发三阶段
1. 捕获阶段：从 window 对象沿着 DOM 树往下依次传播。
2. 触发阶段：目标事件处理
3. 冒泡阶段：处理完成，逐级向上冒泡，直到 window 节点

##### 传播起点
DOM2 级事件规范要求事件应该从 document 对象开始传播，但是浏览器都是从 window 对象开始传播的

##### 事件传播方式
addEventListener 第三个参数选择事件传播方式，默认为 false
* true：在捕获阶段调用事件处理
* false：在冒泡阶段调用事件处理

##### 阻止事件传播
event.stopPropagation()，既能够阻止事件冒泡，也能够阻止事件捕获。但是无法阻止该元素绑定的其他事件

event.stopImmediatePropagation()，能阻止事件冒泡、事件捕获和绑定的其他事件

**每次定义的事件只会因为捕获或者冒泡触发一次！！！**
**同一个节点中，既绑定了冒泡事件，也绑定了捕获事件，将会按照绑定的顺序执行**

### 事件代理/事件委托
利用事件冒泡的原理，不需要为每一个子节点单独设置事件，event.target(event.srcElement) 表示当前操作的 DOM 节点。

1. 节省内存，因为每个函数都是一个对象，都会占用内存
2. 不需要给子节点注销事件


## 跨域
浏览器出于安全考虑，有同源策略。也就是协议、域名或端口有一个不同，就是跨域。

##### 原因
主要用来防止 CSRF(利用用户的登录状态发起恶意请求) 攻击

#### 解决跨域问题

###### JSONP
利用 script 标签没有跨域限制的漏洞，新增一个 script 标签指向需要访问的地址并提供一个回调函数来接收数据。仅用于 get 请求

###### CORS
服务端设置 Access-Control-Allow-Origin 开启

###### document.domain
二级域名相同情况下，添加document.domain 即可实现跨域

###### postMessage
用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息

## 存储

### 不同的存储方式

###### cookie
* 由服务器生成，可以设置过滤时间
* 最大支持 4k 内容
* 每次与服务器通信时，都会携带在 header 中，对于请求性能有影响

###### localStorage
* 本地存储，除非被清理，否则一直存在
* 最大支持 5M 内容
* 本地存储，不与服务器通信

###### sessionStorage
* 本地生成，页面关闭就会被清理
* 最大支持 5M 内容
* 本地存储，不与服务器通信

###### indexDB
* 本地生成，除非被清理，否则一直存在
* 大小无限制
* 本地存储，不与服务器通信

### Service Worker
运行在浏览器背后的独立线程，用来实现缓存功能。由于 Service Worker 中涉及到请求拦截，所以 HTTPS 才能使用

## 缓存机制
一个数据请求，可以分为网络请求，后端处理，浏览器响应三个步骤。浏览器缓存能在第一步和第三步优化性能。

#### 缓存位置
从位置上分为四种，当全部都没有缓存时，才会去请求网络

###### Service Worker

###### Memory Cache 内存缓存
内存中的缓存读取高效，但是持续性短，会随着进程的释放而释放。一旦关闭 tab 页面，Memory Cache 就会被释放
###### Disk Cache
硬盘中的缓存
###### Push Cache
只在 Session 中存在，一旦会话结束就会被释放

#### 缓存策略
通常浏览器缓存策略有两种，分别是强缓存和协商缓存，都是通过设置 header 来实现

##### 强缓存
表示缓存期间不需要重新发送请求。设置 Expires 和 Cache-Control 来实现

###### Expires 过期时间
`Expires: Wed, 22 Oct 2018 08:41:00 GMT`

Expires 是 HTTP/1 的产物，后面跟一个时间点，在设置的时间点之后再次发送请求。

**Expires 受限于本地时间，修改了会造成缓存失效**

###### Cache-Control 相对过期时间
`Cache-control: max-age=30`

优先级高于 Expires，
##### 协商缓存
通过设置 Last-Modified 和 ETag 验证资源是否有更新

当浏览器发起请求验证资源，如果资源没变，服务器就会返回 304，并且更新浏览器缓存有效期

###### Last-modified 和 If-Modified-Since
Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器资源是否有更新，有更新的话会将新的资源发送回来，否则返回 304 状态码

Last-Modified 的弊端：
* 打开本地缓存文件，Last-Modified 会被修改，服务器不能命中
* Last-Modified 只能以秒计时，在不可感知的时间内修改完文件，依然无法命中

###### ETag 和 If-None-Match
ETag 类似于文件指纹，If-Node-Match 会将 ETag 发送给服务器，询问该资源是否变动，有变动就返回新资源。优先级比 Last-Modified 高

### 实际应用

##### 频繁变动的资源
首先使用 Cache-Control: no-cache 使浏览器每次请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。能显著减少响应的数据大小

##### 代码文件
HTML 文件一般不缓存或者缓存时间很短

其他文件对文件名进行哈希处理，设置 Cache-Control: max-age:31536000，这样只有当 HTML 文件中引入的文件名改变才回去下载最新的文件


## 渲染原理

### 浏览器接收到 HTML 文件并转换为 DOM 树
浏览器下载完 HTML 文件之后，根据字符串中标记转换成 Node，并转换成 DOM 树。遇到 CSS 和 JS 文件时，浏览器会下载并解析这些文件

### 将 CSS 文件转换为 CSSOM 树
浏览器根据字符串中标记转换成 Node，并转换成 CSSOM

这个过程中，浏览器会确定每一个节点的样式，这一过程很消耗资源

### 生成渲染树
DOM 树和 CSSOM 树合并生成渲染树，根据渲染树进行布局，然后调用 GPU 绘制，合成图层，显示在屏幕上

### 为什么操作 DOM 慢
DOM 是渲染引擎中的东西，JS 是 JS 引擎中的东西，通过 JS 操作 DOM 时，涉及到两个线程间的通信，会有性能上的损耗。操作 DOM 次数越多，性能越差

插入几万个 DOM,分批次部分渲染，使用 requestAnimationFrame 循环插入 DOM 或者虚拟滚动

### 阻塞渲染

### 重绘和回流
重绘：节点更改外观但是不影响布局

回流：节点布局改变或节点几何属性需要改变，成本大大高于重绘

与事件循环的关系
1. 当事件循环执行完微任务之后，会判断 document 是否需要更新，浏览器每 16.6ms 会更新一次
2. resize 或者 scroll 事件会触发回流，并且自带节流事件
3. media query
4. 更新动画
5. 全屏操作事件
6. requestAnimationFrame 回调
7. IntersectionObserer 回调
8. 更新界面

### 减少重绘和回流
1. 使用 transform 替代 top 来实现动画
2. 使用 visibility 替换 diaplay: none，前者只会引起重绘，后者会触发回流
3. 不要把 DOM 放在已循环中作为循环变量
4. 不要用 table 布局
5. 动画选择用 requestAnimationFrame，因为速度越快，回流次数越多
6. css 选择符**从右往左**匹配查找，避免节点层级过多
7. 将频繁回流或者重绘的节点设置为图层


## 安全防范

### XSS 攻击
XSS 就是攻击者将可执行代码注入到网页中。一般分为持久型和非持久型
* 持久型：攻击代码被服务端写入到数据库中
* 非持久型：一般通过修改 URL 参数的方式加入攻击代码等

#### 防御 XSS 攻击
1. 使用转义字符，对于引号，尖括号，斜杠等进行转义
2. 建立白名单，配置自己的拦截规则

### CSRF 攻击
CSRF 是请求伪造信息，原理是攻击者构造出一个后端请求地址，诱导用户点击或进行某些途径自动发起请求

#### 防御 CSRF 攻击
1. get 请求不对数据进行修改
2. 不让第三方网站访问到用户 cookie
3. 阻止第三方网站请求接口
4. 请求时附带验证信息

### 点击劫持
一种视觉攻击手段，通过 iframe 嵌入网站，并设置透明，诱导用户点击

#### 防御
1. X-FRAME-OPTIONS：添加响应头
2. JS 防御

### 中间人攻击
同时与服务端和客户端建立起了连接，并让对方觉得是安全的

#### 防御
使用 HTTPS 传输信息
