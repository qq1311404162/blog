## UDP

##### 面向无连接
发送数据前无需与服务器进行连接，服务端也不会对数据进行验证

UDP 协议只是数据的搬运工，不会对内容进行任何拆分和拼接操作

具体步骤：
1. UDP 只会给数据增加一个 UDP 头标识，然后传输给网络层
2. 服务端收到 UDP 信息，仅仅去除报文头，不会做任何拼接操作

##### 不可靠性
由于无连接，无法确保消息一定送达
##### 高效
头标识仅 8 字节，数据包小，所以传输块

UDP 头部包含数据
* 两个十六位的端口号，分别为源端口(可选)和目标端口
* 整个数据报文的长度
* 数据报文的检验，用于发现头信息和数据中的错误

##### 传输方式不用固定
UDP 支持一对一，一对多，多对多，多对一等所有传输方式。也就是提供了单播，多播，广播的功能

##### 适用场景
由于高效性，一般实时性要求高的地方都适用


## TCP

### 与 UDP 的区别
* TCP 需要先与服务器建立连接才能发送信息
* TCP 保证数据的准确性，发送的数据一定要到达
* TCP 头部 20 字节，传输较慢
* TCP 只能一对一传输
* TCP 是全双工可靠信道，UDP 则是不可靠信道

握手字符串解析
* SYN：SYN = 1，代表此次握手用于建立连接
* ACK：ACK = 1，代表消息接收成功
* FIN：FIN = 1，代表请求关闭连接
* seq：序列号，发送数据时，数据是被拆分成多个数据包来发送的，使用序列号对每个数据进行编号，这样接收方才能对数据进行再次拼接。初始序列号都是随机生成的
* ack：下一个数据包的编号

SYN、ACK、FIN 是存放在 TCP 的标志位，一共 6 个字符
### 建立连接

###### 第一次握手
客户端发送 SYN = 1，seq = x(随机) 的请求给服务端，表示要创建连接，客户端进入 SYN-SENT 状态

###### 第二次握手
服务器收到后，向客户端发送 SYN = 1, ACK = 1，ack = x + 1， seq = y(随机)，服务端进入 SYN-RECV 状态

###### 第三次握手
客户端收到后，再次向服务端发送 ACK = 1，seq = x + 1, ack = y + 1 确认包，发送完毕后，客户端和服务端同时进入 ESTABLISHED 状态，完成握手

#### 第三次握手的原因
为了防止出现失效的连接请求被服务器接收，从而出现错误

### 断开连接

###### 第一次握手
客户端发送 FIN = 1，seq = x(随机) 的请求给服务端，表示要关闭一个连接，此时客户端进入 FIN-WAIT-1 状态
###### 第二次握手
服务端收到后，向客户端发送 ACK = 1，seq = y(随机)，ack = x + 1，此时进入 CLOSE_WAIT 状态，此时不再接收客户端的数据。由于 TCP 是双向的，此时服务端仍然可以发送数据给服务端

客户端收到服务端的确认应答后，会进入 FIN-WAIT-2 状态
###### 第三次握手
服务器发送完数据后，向客户端发送 FIN = 1，ACK = 1，seq = z(随机)，ack = x + 1，此时服务器进入 LAST-ACK 状态
###### 第四次握手
客户端收到后，向服务端发送 ACK = 1，seq = x + 1，ack = z + 1 确认应答，此时客户端进入 TIME-WAIT 状态，该状态持续 2msl 时间，若该时间段内没有再次收到服务器的请求，则进入 CLOSE 状态。

服务器收到客户端的确认应答后，变回进入 CLOSE 状态

## HTTP 及 TLS
HTTP(Hyper Text Transfer Protocol) 协议是一种基于 TCP 的应用层协议，不关心数据传输的细节，主要用来规定客户端和服务器的传输格式

### 协议版本
###### 0.9 版本     1991年
这个版本最初用来向客户端传输 HTML 页面的，只有一个 GET 命令，服务器只能返回 HTML 页面
###### 1.0 版本     1996年
奠定了现在的 HTTP 协议的基础。不仅可以传输 HTML，还能传输其他二进制文件。

增加了 POST 和 HEAD 命令。

请求消息和响应消息中规定了一些元数据字段，例如字符集、编码、状态响应码等

###### 1.1 版本     1997年
增加了持久连接(keep-alive)，之前的一次请求就是一次 TCP 连接，请求完毕后连接就关掉。1.1 版本默认不关闭 TCP 连接，默认持久连接开启。
<!-- TCP 协议 建立 3 次握手，断开 4 次握手，有流量控制和拥塞控制，慢开始机制 -->
引入了管道机制，即一个 TCP 连接内可以同时发送多个 HTTP 请求，不必等待上一个请求响应成功再发送

增加了 PUT、PATCH、HEAD、OPTIONS、DELETE 等 命令

头部增加了 Host 字段

###### 2 版本       2005年
管道机制在服务端还是要对请求进行排队处理，这个版本可以多工处理

头信息压缩和服务器主动推送

###### HTTPS(TLS)
HTTP 的安全版本，HTTP 的数据都是明文的，HTTPS 使用了 TLS/SSL 协议进行了加密处理

### HTTP 特点
1. HTTP 协议是无状态的

每次 HTTP 请求都是独立的，任何两个请求之间没有什么必然联系。**实际应用中，使用 Cookie 和 Session 机制来关联请求**

2. 多次 HTTP 请求

客户端请求网页时，服务端首先响应 HTML 页面，浏览器响应之后会自动发送 HTTP 请求额外的资源

3. 基于 TCP 协议

HTTP 协议是基于 TCP 协议实现的应用层协议

### HTTP 报文
HTTP 报文由请求行，首部，实体三部分组成，每一行的末尾都有回车和换行，实体和首部之间有一个空行

##### 请求行
###### 请求报文的请求行
`GET /wxisme HTTP/1.1`，由请求方式，URL 和协议版本组成
###### 响应报文的请求行
`HTTP/1.1 200 OK`，由协议版本、状态码和状态短语组成

##### 首部
首部分为请求首部和响应首部，其中部分首部两种通用
###### 通用首部
字段名称|作用
---|:--:
Cache-Control | 缓存策略
Connection | 浏览器使用的连接类型
Date | 创建报文时间
Pragma | 报文指令
Via | 代理服务器相关信息
Transfer-Encoding | 传输编码方式
Upgrade | 要求客户端升级协议
Warning | 内容中可能存在错误
###### 请求首部
字段名称|作用
---|:--:
Accept | 正确接收的媒体类型
Accept-Charset | 正确接收的字符集
Accept-Encoding | 正确接收的编码格式
Accept-Language | 正确接收的语言
Expect | 期待服务端的指定行为
From | 请求方邮箱地址
Host | 服务器域名
If-Match | 两端资源标记比较
If-Modified-Since | 
If-None-Match | 
User-Agent | 客户端信息
Max-Forwards | 限制可被代理及网关转发的次数
Proxy-Authorization | 向代理服务器发送验证信息
Range | 请求某个内容的一部分
Referer | 浏览器访问的前一个页面
TE | 传输编码方式
###### 响应首部
。。。
##### 实体
实体和首部之间有一个空行

传输的数据

https://www.cnblogs.com/wxisme/p/6212797.html

### HTTP 请求方法
### HTTP 响应码
## HTTP/2 及 HTTP/3
## 输入 URL 到页面显示的整个流程