## UDP

##### 面向无连接
发送数据前无需与服务器进行连接，服务端也不会对数据进行验证

UDP 协议只是数据的搬运工，不会对内容进行任何拆分和拼接操作

具体步骤：
1. UDP 只会给数据增加一个 UDP 头标识，然后传输给网络层
2. 服务端收到 UDP 信息，仅仅去除报文头，不会做任何拼接操作

##### 不可靠性
由于无连接，无法确保消息一定送达
##### 高效
头标识仅 8 字节，数据包小，所以传输块

UDP 头部包含数据
* 两个十六位的端口号，分别为源端口(可选)和目标端口
* 整个数据报文的长度
* 数据报文的检验，用于发现头信息和数据中的错误

##### 传输方式不用固定
UDP 支持一对一，一对多，多对多，多对一等所有传输方式。也就是提供了单播，多播，广播的功能

##### 适用场景
由于高效性，一般实时性要求高的地方都适用


## TCP

### 与 UDP 的区别
* TCP 需要先与服务器建立连接才能发送信息
* TCP 保证数据的准确性，发送的数据一定要到达
* TCP 头部 20 字节，传输较慢
* TCP 只能一对一传输
* TCP 是全双工可靠信道，UDP 则是不可靠信道

握手字符串解析
* SYN：SYN = 1，代表此次握手用于建立连接
* ACK：ACK = 1，代表消息接收成功
* FIN：FIN = 1，代表请求关闭连接
* seq：序列号，发送数据时，数据是被拆分成多个数据包来发送的，使用序列号对每个数据进行编号，这样接收方才能对数据进行再次拼接。初始序列号都是随机生成的
* ack：下一个数据包的编号

SYN、ACK、FIN 是存放在 TCP 的标志位，一共 6 个字符
### 建立连接

###### 第一次握手
客户端发送 SYN = 1，seq = x(随机) 的请求给服务端，表示要创建连接，客户端进入 SYN-SENT 状态

###### 第二次握手
服务器收到后，向客户端发送 SYN = 1, ACK = 1，ack = x + 1， seq = y(随机)，服务端进入 SYN-RECV 状态

###### 第三次握手
客户端收到后，再次向服务端发送 ACK = 1，seq = x + 1, ack = y + 1 确认包，发送完毕后，客户端和服务端同时进入 ESTABLISHED 状态，完成握手

#### 第三次握手的原因
为了防止出现失效的连接请求被服务器接收，从而出现错误

### 断开连接

###### 第一次握手
客户端发送 FIN = 1，seq = x(随机) 的请求给服务端，表示要关闭一个连接，此时客户端进入 FIN-WAIT-1 状态
###### 第二次握手
服务端收到后，向客户端发送 ACK = 1，seq = y(随机)，ack = x + 1，此时进入 CLOSE_WAIT 状态，此时不再接收客户端的数据。由于 TCP 是双向的，此时服务端仍然可以发送数据给服务端

客户端收到服务端的确认应答后，会进入 FIN-WAIT-2 状态
###### 第三次握手
服务器发送完数据后，向客户端发送 FIN = 1，ACK = 1，seq = z(随机)，ack = x + 1，此时服务器进入 LAST-ACK 状态
###### 第四次握手
客户端收到后，向服务端发送 ACK = 1，seq = x + 1，ack = z + 1 确认应答，此时客户端进入 TIME-WAIT 状态，该状态持续 2msl 时间，若该时间段内没有再次收到服务器的请求，则进入 CLOSE 状态。

服务器收到客户端的确认应答后，变回进入 CLOSE 状态


## HTTP 及 TLS
HTTP(Hyper Text Transfer Protocol) 协议是一种基于 TCP 的应用层协议，不关心数据传输的细节，主要用来规定客户端和服务器的传输格式

https://www.cnblogs.com/wxisme/p/6212797.html

### 协议版本
###### 0.9 版本     1991年
这个版本最初用来向客户端传输 HTML 页面的，只有一个 GET 命令，服务器只能返回 HTML 页面
###### 1.0 版本     1996年
奠定了现在的 HTTP 协议的基础。不仅可以传输 HTML，还能传输其他二进制文件。

增加了 POST 和 HEAD 命令。

请求消息和响应消息中规定了一些元数据字段，例如字符集、编码、状态响应码等

###### 1.1 版本     1997年
增加了持久连接(keep-alive)，之前的一次请求就是一次 TCP 连接，请求完毕后连接就关掉。1.1 版本默认不关闭 TCP 连接，默认持久连接开启。
<!-- TCP 协议 建立 3 次握手，断开 4 次握手，有流量控制和拥塞控制，慢开始机制 -->
引入了管道机制，即一个 TCP 连接内可以同时发送多个 HTTP 请求，不必等待上一个请求响应成功再发送

增加了 PUT、PATCH、HEAD、OPTIONS、DELETE 等 命令

头部增加了 Host 字段

###### 2 版本       2005年
管道机制在服务端还是要对请求进行排队处理，这个版本可以多工处理

header 信息压缩和服务器主动推送

###### HTTPS(TLS)
HTTP 的安全版本，HTTP 的数据都是明文的，HTTPS 使用了 TLS/SSL 协议进行了加密处理

### HTTP 特点
1. HTTP 协议是无状态的

每次 HTTP 请求都是独立的，任何两个请求之间没有什么必然联系。**实际应用中，使用 Cookie 和 Session 机制来关联请求**

2. 多次 HTTP 请求

客户端请求网页时，服务端首先响应 HTML 页面，浏览器响应之后会自动发送 HTTP 请求额外的资源

3. 基于 TCP 协议

HTTP 协议是基于 TCP 协议实现的应用层协议

### HTTP 报文
HTTP 报文由请求行，首部，实体三部分组成，每一行的末尾都有回车和换行，实体和首部之间有一个空行

##### 请求行
###### 请求报文的请求行
`GET /wxisme HTTP/1.1`，由请求方式，URL 和协议版本组成
###### 响应报文的请求行
`HTTP/1.1 200 OK`，由协议版本、状态码和状态短语组成

##### 首部
首部分为请求首部和响应首部，其中部分首部两种通用
###### 通用首部
字段名称|作用
---|:--:
Cache-Control | 缓存策略
Connection | 浏览器使用的连接类型
Date | 创建报文时间
Pragma | 报文指令
Via | 代理服务器相关信息
Transfer-Encoding | 传输编码方式
Upgrade | 要求客户端升级协议
Warning | 内容中可能存在错误
###### 请求首部
字段名称|作用
---|:--:
Accept | 正确接收的媒体类型
Accept-Charset | 正确接收的字符集
Accept-Encoding | 正确接收的编码格式
Accept-Language | 正确接收的语言
Expect | 期待服务端的指定行为
From | 请求方邮箱地址
Host | 服务器域名
If-Match | 两端资源标记比较
If-Modified-Since | 
If-None-Match | 
User-Agent | 客户端信息
Max-Forwards | 限制可被代理及网关转发的次数
Proxy-Authorization | 向代理服务器发送验证信息
Range | 请求某个内容的一部分
Referer | 浏览器访问的前一个页面
TE | 传输编码方式
###### 响应首部
。。。
##### 实体
实体和首部之间有一个空行

传输的数据


### HTTP 请求方法
请求方法是客户端用来告知服务器其动作意图的方法，需要用大写字母
###### GET 获取资源
用来请求访问被 URI 识别的资源
###### POST 传输数据
用来传输数据实体
###### OPTIONS 询问支持的方法
有些服务器为了安全，会禁用一些方法，OPTIONS 用来询问服务器支持的方法
###### PUT 传输文件
用来传输文件，类似于 FTP 协议，文件包含在报文实体中
###### HEAD 获得报文首部
类似 GET 方法，但是此方法不要求服务器返回数据实体。用于确认 URI 的有效性及资源更新时间等
###### DELETE 删除文件
用来删除服务器的资源
###### TRACE 追踪路径
让 WEB 服务器将之前的请求通过通信环回给客户端的方法
###### CONNECT 要求用隧道协议连接处理
要求在与代理服务器通信时建立隧道
### HTTP 响应码
用来告知客户端服务器处理请求的结果。凭借状态码用户可以知道服务器的请求状态，好定位错误

状态码|类别|原因
---|:--:|--:
1xx | Infomational(信息性状态码) | 接收的请求正在处理
2xx | Success(成功状态码)        | 请求正常处理完毕
3xx | Redirection(重定向状态码)  | 需要进行附加操作以完成请求
4xx | Client Error(客户端错误)   | 服务器无法处理请求
5xx | Server Error(服务器错误)   | 服务器处理请求出错

##### 常用状态码
###### 200 OK
请求正常处理
###### 204 No Content
请求处理成功，不允许也没有实体返回。HEAD 请求可能就会返回 204
###### 301 Moved Permanently
永久重定向，请求资源已经被分配了新的 URL，应该使用新的 URL 进行访问
###### 302 Found
临时重定向，请求资源已经被分配了新的 URL，但是可能还会改变
###### 304 Not Modified
服务器允许访问资源，但请求未满足条件。该状态码不返回任何数据实体，与重定向无关
###### 400 Bad Request
请求存在语法错误
###### 401 Unauthorized
发送的请求需要通过 HTTP 认证的认证信息
###### 403 Forbidden
请求被拒绝，没有访问服务器的权限，ip 被禁止等
###### 404 Not Found
请求的资源在服务器上找不到
###### 408 Request Timeout
客户端请求超时。客户端与服务器建立连接后，服务器在一定时间内没有收到客户端的请求
###### 500 Internal Server Error
服务器执行出错
###### 502 Bad Gateway
网关或代理服务器执行请求时，从应用服务器接收到无效响应
###### 503 Service Unavailable
服务器处于超负载或正在停机维护中，无法处理请求
###### 504 Gateway Timeout
网关超时，代理服务器等待应用服务器响应时超时

### 常见问题
#### GET 和 POST 的区别
1. 从规范来看，GET 用于获取资源信息，POST 用于更新资源信息
2. GET 请求的数据实体会放在 URL 后面，用 ? 分割，参数用 & 连接
3. GET 请求的数据长度有限制，因为 URL 的长度有限制。POST 没有
4. GET 提交的数据不安全，数据都会暴露在 URL 上
5. POST 支持不同的编码类型且不对数据类型限制
#### 408 和 504 的区别
* 408 是建立连接之后在约定的时间内，客户端没有发送请求到服务端。
* 504 是网关超时，是代理服务器把客户端请求转发到服务器后，在约定的时间内没有收到服务器的响应。
#### Cookie 和 Session 的区别和联系
* 两者都是从服务器生成，但是 Cookie 会保存在客户端，Session 会保存在服务端
* Cookie大小和数量都有限制，每次请求都会被附带，影响了传输效率。Cookie 在客户端可能被禁用、篡改、删除，不安全
* Session 是基于 Cookie 实现，存在于服务端，每次请求时只是把代表客户端的唯一 ID(JSESSIONID) 写在客户端的 Cookie 中。Session 不做特殊处理容易失效、过期、丢失或过多导致服务器内存溢出

## 输入 URL 到页面显示的整个流程
1. 获取 IP 地址
    1. 查看浏览器是否缓存 URL，有就直接向服务器发送请求
    2. 浏览器没有缓存，则在本地 hosts 文件中查找是否缓存该 URL 和对应的 IP，有就直接向服务器发送请求
    3. 如果没有缓存，则向本地 DNS 服务器发送 UDP 请求，服务器会查询缓存记录，有就将 IP 返回给浏览器
    4. DNS 服务器没有记录，则向域名服务器发送 DNS 查询请求，返回 IP 地址
2. TCP 连接，TCP 三次握手，连接服务器
3. 浏览器向服务器发送 HTTP 请求，获取资源
    * 静态资源：请求静态资源，服务器根据 URL 地址到服务器对应路径查找文件，然后返回 HTTP 响应
    * 动态资源：服务器调用 CGI/VM 执行程序完成相应操作，将运行结果返回给客户端
4. 浏览器渲染
    1. 解析 HTML，构建 DOM 树
    2. 下载并解析 CSS，构建 CSSOM 树
    3. 同步 JS 文件，暂停 DOM 构建，下载并执行文件；异步 JS 文件，不暂停 DOM 构建，下载文件，等待 DOM 树构建完毕再执行
    4. DOM 构建完毕，触发 DOMContentLoaded 事件
    5. CSSOM 树和 DOM 树生成 render 树，调用 GPU 合成图层，将结果显示在屏幕中
    * 生成 render 树过程中，浏览器就开始调用 GPU 绘制
    6. 页面中所有资源加载完毕，触发 onload 事件
5. TCP 断开，四次握手，释放服务器资源
