## UDP

##### 面向无连接
发送数据前无需与服务器进行连接，服务端也不会对数据进行验证

UDP 协议只是数据的搬运工，不会对内容进行任何拆分和拼接操作

具体步骤：
1. UDP 只会给数据增加一个 UDP 头标识，然后传输给网络层
2. 服务端收到 UDP 信息，仅仅去除报文头，不会做任何拼接操作

##### 不可靠性
由于无连接，无法确保消息一定送达
##### 高效
头标识仅 8 字节，数据包小，所以传输块

UDP 头部包含数据
* 两个十六位的端口号，分别为源端口(可选)和目标端口
* 整个数据报文的长度
* 数据报文的检验，用于发现头信息和数据中的错误

##### 传输方式不用固定
UDP 支持一对一，一对多，多对多，多对一等所有传输方式。也就是提供了单播，多播，广播的功能

##### 适用场景
由于高效性，一般实时性要求高的地方都适用


## TCP

### 与 UDP 的区别
* TCP 需要先与服务器建立连接才能发送信息
* TCP 保证数据的准确性，发送的数据一定要到达
* TCP 头部 20 字节，传输较慢
* TCP 只能一对一传输
* TCP 是全双工可靠信道，UDP 则是不可靠信道

握手字符串解析
* SYN：SYN = 1，代表此次握手用于建立连接
* ACK：ACK = 1，代表消息接收成功
* FIN：FIN = 1，代表请求关闭连接
* seq：序列号，发送数据时，数据是被拆分成多个数据包来发送的，使用序列号对每个数据进行编号，这样接收方才能对数据进行再次拼接。初始序列号都是随机生成的
* ack：下一个数据包的编号

SYN、ACK、FIN 是存放在 TCP 的标志位，一共 6 个字符
### 建立连接

###### 第一次握手
客户端发送 SYN = 1，seq = x(随机) 的请求给服务端，表示要创建连接，客户端进入 SYN-SENT 状态

###### 第二次握手
服务器收到后，向客户端发送 SYN = 1, ACK = 1，ack = x + 1， seq = y(随机)，服务端进入 SYN-RECV 状态

###### 第三次握手
客户端收到后，再次向服务端发送 ACK = 1，seq = x + 1, ack = y + 1 确认包，发送完毕后，客户端和服务端同时进入 ESTABLISHED 状态，完成握手

#### 第三次握手的原因
为了防止出现失效的连接请求被服务器接收，从而出现错误

### 断开连接

###### 第一次握手
客户端发送 FIN = 1，seq = x(随机) 的请求给服务端，表示要关闭一个连接，此时客户端进入 FIN-WAIT-1 状态
###### 第二次握手
服务端收到后，向客户端发送 ACK = 1，seq = y(随机)，ack = x + 1，此时进入 CLOSE_WAIT 状态，此时不再接收客户端的数据。由于 TCP 是双向的，此时服务端仍然可以发送数据给服务端

客户端收到服务端的确认应答后，会进入 FIN-WAIT-2 状态
###### 第三次握手
服务器发送完数据后，向客户端发送 FIN = 1，ACK = 1，seq = z(随机)，ack = x + 1，此时服务器进入 LAST-ACK 状态
###### 第四次握手
客户端收到后，向服务端发送 ACK = 1，seq = x + 1，ack = z + 1 确认应答，此时客户端进入 TIME-WAIT 状态，该状态持续 2msl 时间，若该时间段内没有再次收到服务器的请求，则进入 CLOSE 状态。

服务器收到客户端的确认应答后，变回进入 CLOSE 状态

## HTTP 及 TLS
## HTTP/2 及 HTTP/3
## 输入 URL 到页面显示的整个流程